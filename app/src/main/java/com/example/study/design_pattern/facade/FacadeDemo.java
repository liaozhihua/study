package com.example.study.design_pattern.facade;

/**
 * 外观模式： 参考https://www.kancloud.cn/digest/xing-designpattern/143728 写的还可以
 * https://www.jianshu.com/p/f9d250ed59dc 普通吧 正常例子而已
 * https://www.its404.com/article/sdkfjksf/52816893 这个例子比较合理 还有源码中使用
 * 结构型模式
 * --------------------
 *外观模式是 “迪米特法则” 的典型应用，优点如下：
 *     1）、降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类，便于子系统内部维护和扩展。
 *     2）、对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易，降低了复杂性。
 *     3）、降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因此编译一个子系统不会影响其他子系统，也不会影响外观对象。
 *     4）、子系统也不会影响外观系统。
 *     5）、通过合理的使用外观系统，可以更好的帮我们划分访问层次，当系统需要层次设计时，可以考虑外观模式。
 *     6）、在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facad类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性
 *     7）、不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。
 *
 * 外观模式的主要缺点如下：
 *     1）、不能很好地限制客户端使用子类系统。
 *     2）、增加了新的子类系统可能需要修改外观类。
 *     ------------------------------------------
 *      外观模式主要包含一下三种角色：
 *     【1】、外观（Facade）角色：为多个子系统对外提供一个共同的接口。
 *     【2】、子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
 *     【3】、客户（Client）角色：通过一个外观系统访问各个子系统。
 */
public class FacadeDemo {
    public static void main(String[] args) {
        //外观类
        Facade facade = new Facade();
        //打开电脑
        facade.open();
        //关闭电脑
        facade.down();
    }
}
